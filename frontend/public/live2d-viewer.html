<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ema Live2D Viewer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { 
      width: 100%; height: 100%; overflow: hidden; 
      background: radial-gradient(circle at 50% 80%, #1e293b 0%, #0f172a 100%);
    }
    #canvas { width: 100%; height: 100%; display: block; }
    #loading {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: #94a3b8; font-family: sans-serif; font-size: 14px; pointer-events: none;
      font-weight: bold; letter-spacing: 1px;
    }
  </style>
  
  <script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.5.9/browser/pixi.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.4.0/dist/cubism4.min.js"></script>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="loading">Live2DåŠ è½½ä¸­...</div>

  <script>
    const { Application } = PIXI;
    const { Live2DModel } = PIXI.live2d;

    const MODEL_URL = '/live2d/ema/ema.model3.json';

    const app = new Application({
      view: document.getElementById('canvas'),
      autoStart: true,
      resizeTo: window,
      transparent: true,
      backgroundAlpha: 0,
      resolution: window.devicePixelRatio || 1,
      autoDensity: true
    });

    let model = null;
    let currentViewMode = 'half';

    // ======== é¼ æ ‡è·Ÿéš ========
    let targetX = 0, targetY = 0;
    let currentX = 0, currentY = 0;

    // ======== è¯´è¯çŠ¶æ€ ========
    let isSpeaking = false;
    let currentMouthValue = 0;
    let speakingTimer = null;
    let speakingIntensity = 0;

    // ======== çœ¨çœ¼ ========
    let blinkState = {
      eyeOpenL: 1, eyeOpenR: 1,
      nextBlinkTime: 0, blinking: false,
      blinkPhase: 0, blinkStart: 0
    };

    // ======== æƒ…æ„Ÿç³»ç»Ÿ ========
    // åŸºäºæ¨¡å‹å®é™…å‚æ•°ï¼Œä¸ä¾èµ– expression æ–‡ä»¶
    const EMOTION_PRESETS = {
      normal: {
        ParamEyeLSmile: 0, ParamEyeRSmile: 0,
        ParamMouthForm: 0, ParamBrowLY: 0, ParamBrowRY: 0,
        Param: 0, Param2: 0, Param23: 0,
        Param93: 0, Param82: 0, Param94: 0, Param84: 0
      },
      happy: {
        ParamEyeLSmile: 0.8, ParamEyeRSmile: 0.8,
        ParamMouthForm: 0.6, ParamBrowLY: 0.3, ParamBrowRY: 0.3,
        Param: 0, Param2: 0, Param23: 0,
        Param93: 0, Param82: 0, Param94: 0, Param84: 0
      },
      sad: {
        ParamEyeLSmile: 0, ParamEyeRSmile: 0,
        ParamMouthForm: -0.5, ParamBrowLY: -0.5, ParamBrowRY: -0.5,
        Param: 1, Param2: 0, Param23: 0,       // æµæ³ª
        Param93: 0, Param82: 0, Param94: 0, Param84: 0
      },
      angry: {
        ParamEyeLSmile: 0, ParamEyeRSmile: 0,
        ParamMouthForm: -0.8, ParamBrowLY: -1.0, ParamBrowRY: -1.0,
        Param: 0, Param2: 0, Param23: 0,
        Param93: 0, Param82: 0, Param94: 1, Param84: 0  // ç”Ÿæ°”ç¬¦å·
      },
      surprised: {
        ParamEyeLSmile: 0, ParamEyeRSmile: 0,
        ParamMouthForm: 0, ParamBrowLY: 1.0, ParamBrowRY: 1.0,
        Param: 0, Param2: 0, Param23: 0,
        Param93: 0, Param82: 0, Param94: 0, Param84: 0
      },
      shy: {
        ParamEyeLSmile: 0.5, ParamEyeRSmile: 0.5,
        ParamMouthForm: 0.3, ParamBrowLY: 0.0, ParamBrowRY: 0.0,
        Param: 0, Param2: 0, Param23: 1,       // æŠ¬æ‰‹é®è„¸
        Param93: 0, Param82: 0, Param94: 0, Param84: 0
      },
      thinking: {
        ParamEyeLSmile: 0, ParamEyeRSmile: 0,
        ParamMouthForm: -0.2, ParamBrowLY: 0.5, ParamBrowRY: -0.3,
        Param: 0, Param2: 0, Param23: 0,
        Param93: 0, Param82: 0, Param94: 0, Param84: 0
      },
      dark: {
        ParamEyeLSmile: 0, ParamEyeRSmile: 0,
        ParamMouthForm: -0.5, ParamBrowLY: -0.8, ParamBrowRY: -0.8,
        Param: 0, Param2: 1, Param23: 0,       // é­”å¥³åŒ–
        Param93: 0, Param82: 1, Param94: 0, Param84: 1  // å¤±å»é«˜å…‰ + é˜´æ²‰
      },
      pout: {
        ParamEyeLSmile: 0, ParamEyeRSmile: 0,
        ParamMouthForm: -0.3, ParamBrowLY: -0.3, ParamBrowRY: -0.3,
        Param: 0, Param2: 0, Param23: 0,
        Param93: 1, Param82: 0, Param94: 0, Param84: 0  // å˜Ÿå˜´
      }
    };

    // å½“å‰æƒ…æ„Ÿå‚æ•°ï¼ˆç”¨äºå¹³æ»‘è¿‡æ¸¡ï¼‰
    let emotionCurrent = { ...EMOTION_PRESETS.normal };
    let emotionTransition = {
      active: false, startTime: 0,
      from: {}, to: {}
    };
    const EMOTION_TRANSITION_MS = 600;

    function easeInOut(t) {
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }

    // ======== åŠ è½½æ¨¡å‹ ========
    async function loadModel() {
      try {
        console.log('ğŸ”„ Loading Model:', MODEL_URL);
        
        model = await Live2DModel.from(MODEL_URL, { 
          autoInteract: false,
          autoUpdate: false,
          autoHitTest: false
        });
        
        app.stage.addChild(model);
        resizeModel(currentViewMode);
        startTicker();
        
        document.getElementById('loading').style.display = 'none';
        console.log('âœ… Model Loaded');
        printModelParameters();
        window.parent.postMessage({ type: 'live2d_ready' }, '*');

      } catch (e) {
        console.error('âŒ Load Failed:', e);
        document.getElementById('loading').innerText = 'ERROR: ' + (e.message || 'Unknown');
        window.parent.postMessage({ type: 'live2d_error', message: e.message }, '*');
      }
    }

    function printModelParameters() {
      try {
        const cm = model.internalModel.coreModel;
        const count = cm._model.parameters.count;
        console.log('ğŸ“‹ æ¨¡å‹å‚æ•°åˆ—è¡¨:');
        for (let i = 0; i < count; i++) {
          const id = cm._model.parameters.ids[i];
          const val = cm._model.parameters.values[i];
          const min = cm._model.parameters.minimumValues[i];
          const max = cm._model.parameters.maximumValues[i];
          console.log(`  [${i}] ${id}: ${val.toFixed(2)} (${min} ~ ${max})`);
        }
      } catch(e) { console.warn('å‚æ•°åˆ—è¡¨è·å–å¤±è´¥', e); }
    }

    function resizeModel(mode) {
      if (!model) return;
      currentViewMode = mode;

      const sw = window.innerWidth;
      const sh = window.innerHeight;

      model.anchor.set(0.5, 0.5);

      if (mode === 'full') {
        model.scale.set(0.1);
        model.x = sw * 0.5;
        model.y = sh * 0.55;
        console.log('ğŸ“ è§†å›¾: å…¨èº«, scale: 0.1');
      } else {
        model.scale.set(0.15);
        model.x = sw * 0.5;
        model.y = sh * 0.8;
        console.log('ğŸ“ è§†å›¾: åŠèº«, scale: 0.15');
      }
    }

    // ======== ä¸»å¾ªç¯ ========
    function startTicker() {
      if (!model) return;

      let t = 0;
      blinkState.nextBlinkTime = performance.now() + 2000 + Math.random() * 3000;

      app.ticker.add((delta) => {
        if (!model?.internalModel?.coreModel) return;
        const cm = model.internalModel.coreModel;
        const now = performance.now();

        t += 0.05 * delta;

        // ===== 1. å‘¼å¸ =====
        try { cm.setParameterValueById('ParamBreath', (Math.sin(t * 0.6) + 1) * 0.5); } catch(e) {}

        // ===== 2. æƒ…æ„Ÿè¿‡æ¸¡ =====
        if (emotionTransition.active) {
          const elapsed = now - emotionTransition.startTime;
          const tRaw = Math.min(1, elapsed / EMOTION_TRANSITION_MS);
          const tEase = easeInOut(tRaw);

          for (const key of Object.keys(emotionCurrent)) {
            const from = emotionTransition.from[key] || 0;
            const to = emotionTransition.to[key] || 0;
            emotionCurrent[key] = from + (to - from) * tEase;
          }

          if (tRaw >= 1) {
            emotionTransition.active = false;
            emotionCurrent = { ...emotionTransition.to };
          }
        }

        // åº”ç”¨æƒ…æ„Ÿå‚æ•°
        for (const [paramId, value] of Object.entries(emotionCurrent)) {
          try { cm.setParameterValueById(paramId, value); } catch(e) {}
        }

        // ===== 3. çœ¨çœ¼ =====
        updateBlink(cm, now);

        // ===== 4. é¼ æ ‡å¹³æ»‘è·Ÿéš =====
        currentX += (targetX - currentX) * 0.08;
        currentY += (targetY - currentY) * 0.08;

        // ===== 5. è¯´è¯å¼ºåº¦ =====
        const targetIntensity = isSpeaking ? 1.0 : 0.0;
        speakingIntensity += (targetIntensity - speakingIntensity) * 0.08;

        // ===== 6. å¾…æœº/è¯´è¯æ™ƒåŠ¨ =====
        const idleSwayX = Math.sin(t * 0.7) * 3 + Math.sin(t * 1.3) * 1.5;
        const idleSwayZ = Math.cos(t * 0.5) * 2;

        const speakSwayX = Math.sin(t * 1.8) * 8 + Math.sin(t * 3.1) * 3;
        const speakSwayZ = Math.sin(t * 1.3) * 5;

        const swayX = idleSwayX + speakSwayX * speakingIntensity;
        const swayZ = idleSwayZ + speakSwayZ * speakingIntensity;

        // ===== 7. å†™å…¥ Param85/86/87ï¼ˆè¾“å…¥å‚æ•°ï¼‰ =====
        // è¿™æ˜¯å…³é”®ï¼ç‰©ç†å¼•æ“ä¼šä»è¿™ä¸‰ä¸ªå‚æ•°è®¡ç®—å‡ºå¤´éƒ¨ã€èº«ä½“ã€å¤´å‘ã€è£™å­ç­‰æ‰€æœ‰è”åŠ¨
        const inputX = currentX * 20 + swayX;    // å·¦å³
        const inputY = currentY * 15;             // ä¸Šä¸‹
        const inputZ = currentX * 5 + swayZ;      // å€¾æ–œ

        try {
          cm.setParameterValueById('Param85', Math.max(-30, Math.min(30, inputX)));
          cm.setParameterValueById('Param86', Math.max(-30, Math.min(30, inputY)));
          cm.setParameterValueById('Param87', Math.max(-30, Math.min(30, inputZ)));
        } catch(e) {}

        // ===== 8. çœ¼çƒè·Ÿéšï¼ˆç›´æ¥æ§åˆ¶ï¼Œä¸ç»è¿‡ç‰©ç†ï¼‰ =====
        try {
          cm.setParameterValueById('ParamEyeBallX', Math.max(-1, Math.min(1, currentX * 0.8)));
          cm.setParameterValueById('ParamEyeBallY', Math.max(-1, Math.min(1, currentY * 0.5)));
        } catch(e) {}

        // ===== 9. æ‰‹åŠ¨è§¦å‘ SDK æ›´æ–° =====
        try {
          model.update(app.ticker.deltaMS);
        } catch(e) {}
      });
    }

    // ======== çœ¨çœ¼ ========
    function updateBlink(cm, now) {
      const BLINK_CLOSE_MS = 80;
      const BLINK_OPEN_MS  = 120;

      if (!blinkState.blinking && now >= blinkState.nextBlinkTime) {
        blinkState.blinking = true;
        blinkState.blinkPhase = 1;
        blinkState.blinkStart = now;
      }

      if (blinkState.blinking) {
        if (blinkState.blinkPhase === 1) {
          const p = Math.min(1, (now - blinkState.blinkStart) / BLINK_CLOSE_MS);
          blinkState.eyeOpenL = 1 - p;
          blinkState.eyeOpenR = 1 - p;
          if (p >= 1) { blinkState.blinkPhase = 2; blinkState.blinkStart = now; }
        } else if (blinkState.blinkPhase === 2) {
          const p = Math.min(1, (now - blinkState.blinkStart) / BLINK_OPEN_MS);
          blinkState.eyeOpenL = p;
          blinkState.eyeOpenR = p;
          if (p >= 1) {
            blinkState.blinking = false;
            blinkState.eyeOpenL = 1;
            blinkState.eyeOpenR = 1;
            blinkState.nextBlinkTime = now + (Math.random() < 0.2 ? 200 + Math.random() * 300 : 2000 + Math.random() * 3000);
          }
        }
      }

      try {
        cm.setParameterValueById('ParamEyeLOpen', blinkState.eyeOpenL);
        cm.setParameterValueById('ParamEyeROpen', blinkState.eyeOpenR);
      } catch(e) {}
    }

    // ======== æƒ…æ„Ÿåˆ‡æ¢ ========
    function setEmotion(name) {
      if (!model) return;
      const target = EMOTION_PRESETS[name];
      if (!target) {
        console.warn('âš ï¸ æœªçŸ¥æƒ…æ„Ÿ:', name);
        return;
      }

      console.log('ğŸ˜Š åˆ‡æ¢æƒ…æ„Ÿ:', name);

      emotionTransition.active = true;
      emotionTransition.startTime = performance.now();
      emotionTransition.from = { ...emotionCurrent };
      emotionTransition.to = { ...target };
    }

    // ======== å˜´éƒ¨æ§åˆ¶ ========
    function setMouth(value) {
      if (!model?.internalModel?.coreModel) return;
      currentMouthValue = value;

      try {
        model.internalModel.coreModel.setParameterValueById('ParamMouthOpenY', value);
      } catch(e) {}

      if (value > 0.1) {
        if (!isSpeaking) console.log('ğŸ¤ å¼€å§‹è¯´è¯');
        isSpeaking = true;
        clearTimeout(speakingTimer);
        speakingTimer = setTimeout(() => {
          isSpeaking = false;
          console.log('ğŸ”‡ åœæ­¢è¯´è¯');
        }, 400);
      }
    }

    // ======== æ¶ˆæ¯ç›‘å¬ ========
    window.addEventListener('message', (event) => {
      if (!event.data || typeof event.data !== 'object') return;
      const { type, value, x, y } = event.data;

      if (type === 'mouth') {
        setMouth(value);
      } else if (type === 'expression') {
        // å…¼å®¹æ—§æ¥å£ï¼šæ˜ å°„åˆ°æƒ…æ„Ÿ
        const expressionToEmotion = {
          normal: 'normal', taishou: 'shy',
          liulei: 'sad', monvhua: 'dark'
        };
        setEmotion(expressionToEmotion[value] || 'normal');
      } else if (type === 'emotion') {
        setEmotion(value);
      } else if (type === 'view_mode') {
        resizeModel(value);
      } else if (type === 'pointer_move') {
        targetX = x;
        targetY = y;
      }
    });

    window.addEventListener('resize', () => resizeModel(currentViewMode));

    loadModel();
  </script>
</body>
</html>